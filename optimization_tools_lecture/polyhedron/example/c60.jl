using SparseArrays
using NLPModels
using LinearAlgebra

mutable struct C60 <: NLPModels.AbstractNLPModel
	meta :: NLPModelMeta
	nls_meta :: NLSMeta
	counters :: NLSCounters

	p :: Transpose{Int64,Array{Int64,2}}
	q :: Transpose{Int64,Array{Int64,2}}
	h :: Transpose{Int64,Array{Int64,2}}
	mp :: Int64
	mq :: Int64
	m :: Int64
	l5 :: Float64
	l6 :: Float64
	l :: Vector
	r :: Matrix 
	r1 :: Matrix
	r2 :: Matrix
	r3 :: Matrix

end


function C60()

	nvar = 180
	nequ = 276
	x0 = zeros(nvar)

	meta = NLPModelMeta(nvar, x0=x0, name="C60")
	nls_meta = NLSMeta(nequ, nvar, x0=x0)

	p=[[1,2],[1,5],[1,6],[2,3],[2,7],[3,4],[3,8],  
		[4,5],[4,9],[5,10],[6,11],[6,12],[7,13],[7,14],  
		[8,15],[8,16],[9,17],[9,18],[10,19],[10,20],  
		[11,20],[11,21],[12,13],[12,22],[13,23],  
		[14,15],[14,24],[15,25],[16,17],[16,26],  
		[17,27],[18,19],[18,28],[19,29],[20,30],  
		[21,22],[21,32],[22,33],[23,24],[23,34],  
		[24,35],[25,26],[25,36],[26,37],[27,28],  
		[27,38],[28,39],[29,30],[29,40],[30,31],  
		[31,32],[33,34],[35,36],[37,38],[39,40],  
		[61-1,61-2],[61-1,61-5],[61-1,61-6],[61-2,61-3],  
		[61-2,61-7],[61-3,61-4],[61-3,61-8],[61-4,61-5],  
		[61-4,61-9],[61-5,61-10],[61-6,61-11],[61-6,61-12],  
		[61-7,61-13],[61-7,61-14],[61-8,61-15],[61-8,61-16],  
		[61-9,61-17],[61-9,61-18],[61-10,61-19],[61-10,61-20],  
		[61-11,61-20],[61-11,61-21],[61-12,61-13],[61-12,61-22],  
		[61-13,61-23],[61-14,61-15],[61-14,61-24],[61-15,61-25],  
		[61-16,61-17],[61-16,61-26],[61-17,61-27],[61-18,61-19],  
		[61-18,61-28],[61-19,61-29],[61-20,61-30]];

	q=[[1,3],[1,4],[2,4],[2,5],[3,5],  
		[6,21],[6,22],[11,12],[11,22],[12,21],  
		[7,23],[7,24],[13,14],[13,24],[14,23],  
		[8,25],[8,26],[15,16],[15,26],[16,25],  
		[9,27],[9,28],[17,18],[17,28],[18,27],  
		[10,29],[10,30],[19,20],[19,30],[20,29],  
		[61-1,61-3],[61-1,61-4],[61-2,61-4],[61-2,61-5],[61-3,61-5],  
		[61-6,61-21],[61-6,61-22],[61-11,61-12],[61-11,61-22],[61-12,61-21],  
		[61-7,61-23],[61-7,61-24],[61-13,61-14],[61-13,61-24],[61-14,61-23],  
		[61-8,61-25],[61-8,61-26],[61-15,61-16],[61-15,61-26],[61-16,61-25],  
		[61-9,61-27],[61-9,61-28],[61-17,61-18],[61-17,61-28],[61-18,61-27],  
		[61-10,61-29],[61-10,61-30],[61-19,61-20],[61-19,61-30],[61-20,61-29]];

	h=[[1,10],[1,11],[5,6],[5,20],[6,20],[10,11],  
		[1,7],[1,12],[2,6],[2,13],[6,13],[7,12],  
		[2,8],[2,14],[3,7],[3,15],[7,15],[8,14],  
		[3,9],[3,16],[4,8],[4,17],[8,17],[9,16],  
		[4,10],[4,18],[5,9],[5,19],[9,19],[10,18],  
		[11,30],[11,32],[20,21],[20,31],[21,31],[30,32],  
		[12,23],[12,33],[13,22],[13,34],[22,34],[23,33],  
		[14,25],[14,35],[15,24],[15,36],[24,36],[25,35],  
		[16,27],[16,37],[17,26],[17,38],[26,38],[27,37],  
		[18,29],[18,39],[19,28],[19,40],[28,40],[29,39],  
		[61-1,61-10],[61-1,61-11],[61-5,61-6],[61-5,61-20],[61-6,61-20],[61-10,61-11],  
		[61-1,61-7],[61-1,61-12],[61-2,61-6],[61-2,61-13],[61-6,61-13],[61-7,61-12],  
		[61-2,61-8],[61-2,61-14],[61-3,61-7],[61-3,61-15],[61-7,61-15],[61-8,61-14],  
		[61-3,61-9],[61-3,61-16],[61-4,61-8],[61-4,61-17],[61-8,61-17],[61-9,61-16],  
		[61-4,61-10],[61-4,61-18],[61-5,61-9],[61-5,61-19],[61-9,61-19],[61-10,61-18],  
		[61-11,61-30],[61-11,61-32],[61-20,61-21],[61-20,61-31],[61-21,61-31],[61-30,61-32],  
		[61-12,61-23],[61-12,61-33],[61-13,61-22],[61-13,61-34],[61-22,61-34],[61-23,61-33],  
		[61-14,61-25],[61-14,61-35],[61-15,61-24],[61-15,61-36],[61-24,61-36],[61-25,61-35],  
		[61-16,61-27],[61-16,61-37],[61-17,61-26],[61-17,61-38],[61-26,61-38],[61-27,61-37],  
		[61-18,61-29],[61-18,61-39],[61-19,61-28],[61-19,61-40],[61-28,61-40],[61-29,61-39]];

	p = transpose(hcat(p...))
	q = transpose(hcat(q...))
	h = transpose(hcat(h...))

	mp=size(p,1);
	mq=size(q,1);
	mh=size(h,1);
	m=mp+mq+mh;
	l5=(2*sin(0.3*pi))^2;
	l6=(2*sin(pi/3))^2;
	l=[ones(mp);l5*ones(mq);l6*ones(mh)];
	r=[p; q; h];
	r3=3*r;
	r2=r3.-1;
	r1=r3.-2;

	return C60(meta, nls_meta, NLSCounters(),p,q,h,mp,mq,m,l5,l6,l,r,r1,r2,r3)

end


function NLPModels.residual(nls :: C60, x :: Vector) 

	increment!(nls, :neval_residual)

	d1=x[nls.r1[:,1]]-x[nls.r1[:,2]];
	d2=x[nls.r2[:,1]]-x[nls.r2[:,2]];
	d3=x[nls.r3[:,1]]-x[nls.r3[:,2]];

	return [x[[1,2,3,4,5,7]]; d1.^2+d2.^2+d3.^2-nls.l]

end


function NLPModels.jac_residual(nls :: C60, x :: Vector)

	increment!(nls, :neval_jac_residual)

	d1=x[nls.r1[:,1]]-x[nls.r1[:,2]];
	d2=x[nls.r2[:,1]]-x[nls.r2[:,2]];
	d3=x[nls.r3[:,1]]-x[nls.r3[:,2]];

	DF=sparse(1:6,[1,2,3,4,5,7],ones(6),nls.m+6,180)+  
		sparse(7:nls.m+6,nls.r1[:,1],2d1,nls.m+6,180)+  
		sparse(7:nls.m+6,nls.r1[:,2],-2d1,nls.m+6,180)+  
		sparse(7:nls.m+6,nls.r2[:,1],2d2,nls.m+6,180)+  
		sparse(7:nls.m+6,nls.r2[:,2],-2d2,nls.m+6,180)+  
		sparse(7:nls.m+6,nls.r3[:,1],2d3,nls.m+6,180)+  
		sparse(7:nls.m+6,nls.r3[:,2],-2d3,nls.m+6,180);

	return DF

end


function NLPModels.grad(nls :: C60, x :: Vector)

	increment!(nls, :neval_grad)

	r = residual(nls, x)
	jac_r = jac_residual(nls, x)

	return  jac_r'*r

end
